// SPDX-License-Identifier: Apache-2.0
use std::rc::Rc;

use haxby_opcodes::Opcode as VmOpcode;

use crate::func_builder::{BasicBlock, FunctionBuilder};

pub enum CompilerOpcode {
    Nop,
    Push(u16),
    Push0,
    Push1,
    PushTrue,
    PushFalse,
    PushBuiltinTy(u8),
    PushRuntimeValue(u8),
    Pop,
    Dup,
    Swap,
    Copy(u8),
    Add,
    Sub,
    Mul,
    Div,
    Rem,
    Neg,
    ShiftLeft,
    ShiftRight,
    Not,
    Equal,
    ReadLocal(u8),
    WriteLocal(u8),
    TypedefLocal(u8),
    ReadNamed(u16),
    WriteNamed(u16),
    TypedefNamed(u16),
    ReadIndex(u8),
    WriteIndex(u8),
    ReadAttribute(u16),
    WriteAttribute(u16),
    ReadUplevel(u8),
    LogicalAnd,
    BitwiseAnd,
    LogicalOr,
    BitwiseOr,
    Xor,
    GreaterThan,
    GreaterThanEqual,
    LessThan,
    LessThanEqual,
    JumpTrue(Rc<BasicBlock>),
    JumpFalse(Rc<BasicBlock>),
    Jump(Rc<BasicBlock>),
    JumpIfArgSupplied(u8, Rc<BasicBlock>),
    Call(u8),
    Return,
    TryEnter(Rc<BasicBlock>),
    TryExit,
    Throw,
    BuildList(u32),
    BuildFunction(u8),
    StoreUplevel(u8),
    BuildStruct,
    BuildEnum,
    BuildMixin,
    BindMethod(u8, u16),
    BindCase(u8, u16),
    IncludeMixin,
    NewEnumVal(u16),
    EnumCheckIsCase(u16),
    EnumExtractPayload,
    TryUnwrapProtocol(u8),
    Isa,
    Import(u16),
    LiftModule,
    LoadDylib(u16),
    Assert(u16),
    Halt,
}

impl CompilerOpcode {
    pub fn is_terminal(&self) -> bool {
        match self {
            Self::Nop => false,
            Self::Push(_) => false,
            Self::Push0 => false,
            Self::Push1 => false,
            Self::PushTrue => false,
            Self::PushFalse => false,
            Self::PushBuiltinTy(_) => false,
            Self::PushRuntimeValue(_) => false,
            Self::Pop => false,
            Self::Dup => false,
            Self::Swap => false,
            Self::Copy(_) => false,
            Self::Add => false,
            Self::Sub => false,
            Self::Mul => false,
            Self::Div => false,
            Self::Rem => false,
            Self::Neg => false,
            Self::ShiftLeft => false,
            Self::ShiftRight => false,
            Self::Not => false,
            Self::Equal => false,
            Self::ReadLocal(_) => false,
            Self::WriteLocal(_) => false,
            Self::TypedefLocal(_) => false,
            Self::ReadNamed(_) => false,
            Self::WriteNamed(_) => false,
            Self::TypedefNamed(_) => false,
            Self::ReadIndex(_) => false,
            Self::WriteIndex(_) => false,
            Self::ReadAttribute(_) => false,
            Self::WriteAttribute(_) => false,
            Self::ReadUplevel(_) => false,
            Self::LogicalAnd => false,
            Self::LogicalOr => false,
            Self::Xor => false,
            Self::BitwiseAnd => false,
            Self::BitwiseOr => false,
            Self::LessThan => false,
            Self::GreaterThan => false,
            Self::LessThanEqual => false,
            Self::GreaterThanEqual => false,
            Self::JumpTrue(_) => false,
            Self::JumpFalse(_) => false,
            Self::Jump(_) => true,
            Self::JumpIfArgSupplied(..) => false,
            Self::Call(_) => false,
            Self::Return => true,
            Self::TryEnter(_) => false,
            Self::TryExit => false,
            Self::Throw => true,
            Self::BuildList(_) => false,
            Self::BuildFunction(_) => false,
            Self::StoreUplevel(_) => false,
            Self::BuildStruct => false,
            Self::BuildEnum => false,
            Self::BuildMixin => false,
            Self::BindMethod(..) => false,
            Self::BindCase(..) => false,
            Self::IncludeMixin => false,
            Self::NewEnumVal(_) => false,
            Self::EnumCheckIsCase(_) => false,
            Self::EnumExtractPayload => false,
            Self::TryUnwrapProtocol(_) => false,
            Self::Isa => false,
            Self::Import(_) => false,
            Self::LiftModule => false,
            Self::LoadDylib(_) => false,
            Self::Assert(_) => false,
            Self::Halt => true,
        }
    }

    pub fn byte_size(&self) -> usize {
        match self {
            Self::Nop => 1,
            Self::Push(_) => 3,
            Self::Push0 => 1,
            Self::Push1 => 1,
            Self::PushTrue => 1,
            Self::PushFalse => 1,
            Self::PushBuiltinTy(_) => 2,
            Self::PushRuntimeValue(_) => 2,
            Self::Pop => 1,
            Self::Dup => 1,
            Self::Swap => 1,
            Self::Copy(_) => 2,
            Self::Add => 1,
            Self::Sub => 1,
            Self::Mul => 1,
            Self::Div => 1,
            Self::Rem => 1,
            Self::Neg => 1,
            Self::ShiftLeft => 1,
            Self::ShiftRight => 1,
            Self::Not => 1,
            Self::Equal => 1,
            Self::ReadLocal(_) => 2,
            Self::WriteLocal(_) => 2,
            Self::TypedefLocal(_) => 2,
            Self::ReadNamed(_) => 3,
            Self::WriteNamed(_) => 3,
            Self::TypedefNamed(_) => 3,
            Self::ReadIndex(_) => 2,
            Self::WriteIndex(_) => 2,
            Self::ReadAttribute(_) => 3,
            Self::WriteAttribute(_) => 3,
            Self::ReadUplevel(_) => 2,
            Self::LogicalAnd => 1,
            Self::LogicalOr => 1,
            Self::Xor => 1,
            Self::BitwiseAnd => 1,
            Self::BitwiseOr => 1,
            Self::GreaterThan => 1,
            Self::LessThan => 1,
            Self::GreaterThanEqual => 1,
            Self::LessThanEqual => 1,
            Self::JumpTrue(_) => 3,
            Self::JumpFalse(_) => 3,
            Self::Jump(_) => 3,
            Self::JumpIfArgSupplied(..) => 4,
            Self::Call(_) => 2,
            Self::Return => 1,
            Self::TryEnter(_) => 3,
            Self::TryExit => 1,
            Self::Throw => 1,
            Self::BuildList(_) => 5,
            Self::BuildFunction(_) => 2,
            Self::StoreUplevel(_) => 2,
            Self::BuildStruct => 1,
            Self::BuildEnum => 1,
            Self::BuildMixin => 1,
            Self::BindMethod(..) => 4,
            Self::BindCase(..) => 4,
            Self::IncludeMixin => 1,
            Self::NewEnumVal(_) => 3,
            Self::EnumCheckIsCase(_) => 3,
            Self::EnumExtractPayload => 1,
            Self::TryUnwrapProtocol(_) => 2,
            Self::Isa => 1,
            Self::Import(_) => 3,
            Self::LiftModule => 1,
            Self::LoadDylib(_) => 3,
            Self::Assert(_) => 3,
            Self::Halt => 1,
        }
    }

    pub fn is_jump_instruction(&self) -> Option<Rc<BasicBlock>> {
        match self {
            Self::TryEnter(dst)
            | Self::JumpIfArgSupplied(_, dst)
            | Self::Jump(dst)
            | Self::JumpTrue(dst)
            | Self::JumpFalse(dst) => Some(dst.clone()),
            _ => None,
        }
    }

    pub fn to_opcodes(&self, parent: &FunctionBuilder) -> Vec<VmOpcode> {
        match self {
            Self::Nop => vec![VmOpcode::Nop],
            Self::Push(v) => vec![VmOpcode::Push(*v)],
            Self::Push0 => vec![VmOpcode::Push0],
            Self::Push1 => vec![VmOpcode::Push1],
            Self::PushTrue => vec![VmOpcode::PushTrue],
            Self::PushFalse => vec![VmOpcode::PushFalse],
            Self::PushBuiltinTy(n) => vec![VmOpcode::PushBuiltinTy(*n)],
            Self::PushRuntimeValue(n) => vec![VmOpcode::PushRuntimeValue(*n)],
            Self::Pop => vec![VmOpcode::Pop],
            Self::Dup => vec![VmOpcode::Dup],
            Self::Swap => vec![VmOpcode::Swap],
            Self::Copy(n) => vec![VmOpcode::Copy(*n)],
            Self::Add => vec![VmOpcode::Add],
            Self::Sub => vec![VmOpcode::Sub],
            Self::Mul => vec![VmOpcode::Mul],
            Self::Div => vec![VmOpcode::Div],
            Self::Rem => vec![VmOpcode::Rem],
            Self::Neg => vec![VmOpcode::Neg],
            Self::ShiftLeft => vec![VmOpcode::ShiftLeft],
            Self::ShiftRight => vec![VmOpcode::ShiftRight],
            Self::Not => vec![VmOpcode::Not],
            Self::Equal => vec![VmOpcode::Equal],
            Self::ReadLocal(n) => vec![VmOpcode::ReadLocal(*n)],
            Self::WriteLocal(n) => vec![VmOpcode::WriteLocal(*n)],
            Self::TypedefLocal(n) => vec![VmOpcode::TypedefLocal(*n)],
            Self::ReadNamed(n) => vec![VmOpcode::ReadNamed(*n)],
            Self::WriteNamed(n) => vec![VmOpcode::WriteNamed(*n)],
            Self::TypedefNamed(n) => vec![VmOpcode::TypedefNamed(*n)],
            Self::ReadIndex(n) => vec![VmOpcode::ReadIndex(*n)],
            Self::WriteIndex(n) => vec![VmOpcode::WriteIndex(*n)],
            Self::ReadAttribute(n) => vec![VmOpcode::ReadAttribute(*n)],
            Self::WriteAttribute(n) => vec![VmOpcode::WriteAttribute(*n)],
            Self::ReadUplevel(n) => vec![VmOpcode::ReadUplevel(*n)],
            Self::LogicalAnd => vec![VmOpcode::LogicalAnd],
            Self::LogicalOr => vec![VmOpcode::LogicalOr],
            Self::Xor => vec![VmOpcode::Xor],
            Self::BitwiseAnd => vec![VmOpcode::BitwiseAnd],
            Self::BitwiseOr => vec![VmOpcode::BitwiseOr],
            Self::GreaterThan => vec![VmOpcode::GreaterThan],
            Self::LessThan => vec![VmOpcode::LessThan],
            Self::GreaterThanEqual => vec![VmOpcode::GreaterThanEqual],
            Self::LessThanEqual => vec![VmOpcode::LessThanEqual],
            Self::JumpTrue(dst) => {
                let offset = parent.offset_of_block(dst).expect("invalid block") - 1;
                vec![VmOpcode::JumpTrue(offset)]
            }
            Self::JumpFalse(dst) => {
                let offset = parent.offset_of_block(dst).expect("invalid block") - 1;
                vec![VmOpcode::JumpFalse(offset)]
            }
            Self::Jump(dst) => {
                let offset = parent.offset_of_block(dst).expect("invalid block") - 1;
                vec![VmOpcode::Jump(offset)]
            }
            Self::JumpIfArgSupplied(arg, dst) => {
                let offset = parent.offset_of_block(dst).expect("invalid block") - 1;
                vec![VmOpcode::JumpIfArgSupplied(*arg, offset)]
            }
            Self::Call(n) => vec![VmOpcode::Call(*n)],
            Self::Return => vec![VmOpcode::Return],
            Self::TryEnter(dst) => {
                let offset = parent.offset_of_block(dst).expect("invalid block") - 1;
                vec![VmOpcode::TryEnter(offset)]
            }
            Self::TryExit => vec![VmOpcode::TryExit],
            Self::Throw => vec![VmOpcode::Throw],
            Self::BuildList(v) => vec![VmOpcode::BuildList(*v)],
            Self::BuildFunction(a) => vec![VmOpcode::BuildFunction(*a)],
            Self::StoreUplevel(a) => vec![VmOpcode::StoreUplevel(*a)],
            Self::BuildStruct => vec![VmOpcode::BuildStruct],
            Self::BuildEnum => vec![VmOpcode::BuildEnum],
            Self::BuildMixin => vec![VmOpcode::BuildMixin],
            Self::BindMethod(x, y) => vec![VmOpcode::BindMethod(*x, *y)],
            Self::BindCase(x, y) => vec![VmOpcode::BindCase(*x, *y)],
            Self::IncludeMixin => vec![VmOpcode::IncludeMixin],
            Self::NewEnumVal(v) => vec![VmOpcode::NewEnumVal(*v)],
            Self::EnumCheckIsCase(v) => vec![VmOpcode::EnumCheckIsCase(*v)],
            Self::EnumExtractPayload => vec![VmOpcode::EnumExtractPayload],
            Self::TryUnwrapProtocol(v) => vec![VmOpcode::TryUnwrapProtocol(*v)],
            Self::Isa => vec![VmOpcode::Isa],
            Self::Import(v) => vec![VmOpcode::Import(*v)],
            Self::LiftModule => vec![VmOpcode::LiftModule],
            Self::LoadDylib(n) => vec![VmOpcode::LoadDylib(*n)],
            Self::Assert(v) => vec![VmOpcode::Assert(*v)],
            Self::Halt => vec![VmOpcode::Halt],
        }
    }
}
