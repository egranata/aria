# SPDX-License-Identifier: Apache-2.0
import CompareResult, TotalOrdering from aria.ordering.compare;
import aria.numerics.int.pow;

func pow(x: Int, y: Int) {
    if y == 0 { return 1; }
    if y == 1 { return x; }
    val ret = x;
    while y > 1 {
        ret *= x;
        y -= 1;
    }
    return ret;
}

func max(x,y) {
    return x > y ? x : y;
}

struct Decimal {
    type func parse(v: String) {
        val parts = v.split(".");
        match parts.len() {
            == 1 => {
                val v = Int.parse(parts[0]);
                return v.apply(|value| => This.new_with_parts(value, 0));
            },
            == 2 => {
                val integer_part = Int.parse(parts[0])??;
                val decimal_part = parts[1];
                val scale = decimal_part.len();
                val combined_str = parts[0] + decimal_part;
                val value = Int.parse(combined_str);
                return value.apply(|v| => This.new_with_parts(v, scale));
            }
        } else {
            return Result::Err("invalid decimal string");
        }
    }

    type func new(v: Int|Float) {
        match v {
            isa Int => {
                return This.new_with_parts(v, 0);
            },
            isa Float => {
                # relies on Float.prettyprint doing the right thing
                # really, there should be a way on Float to extract the
                # integer and fractional parts directly
                val s = prettyprint(v);
                val parts = s.split(".");
                match parts.len() {
                    == 1 => {
                        return This.new_with_parts(v.int(), 0);
                    },
                    == 2 => {
                        val decimal_part = parts[1];
                        val scale = decimal_part.len();
                        val value = (v * pow(10, scale)).int();
                        return This.new_with_parts(value, scale);
                    }
                }
            }
        }
    }

    type func new_with_parts(v: Int, s: Int) {
        while s > 0 && v % 10 == 0 {
            v /= 10;
            s -= 1;
        }

        return alloc(This){
            .value = v,
            .scale = s,
        };
    }

    operator u-() {
        return alloc(Decimal){
            .value = -this.value,
            .scale = this.scale,
        };
    }

    reverse operator -(lhs) {
        return -this + lhs;
    }

    reverse operator /(lhs) {
        if lhs isa Int {
            lhs = Decimal.new(lhs);
        } elsif lhs isa Float {
            lhs = Decimal.new(lhs);
        } elsif !(lhs isa Decimal) {
            throw alloc(Unimplemented);
        }

        return lhs / this;
    }

    operator +(other: Int|Float|Decimal) {
        if other isa Int {
            other = Decimal.new(other);
        } elsif other isa Float {
            other = Decimal.new(other);
        }

        if this.scale == other.scale {
            return Decimal.new_with_parts(this.value + other.value, this.scale);
        } else {
            val max_scale = max(this.scale, other.scale);
            val this_value = this.value * pow(10, (max_scale - this.scale));
            val other_value = other.value * pow(10, (max_scale - other.scale));
            return Decimal.new_with_parts(this_value + other_value, max_scale);
        }
    }

    reverse operator +(lhs) {
        return this._op_impl_add(lhs);
    }

    operator -(other: Int|Float|Decimal) {
        if other isa Int {
            other = Decimal.new(other);
        } elsif other isa Float {
            other = Decimal.new(other);
        }

        if this.scale == other.scale {
            return Decimal.new_with_parts(this.value - other.value, this.scale);
        } else {
            val max_scale = max(this.scale, other.scale);
            val this_value = this.value * pow(10, (max_scale - this.scale));
            val other_value = other.value * pow(10, (max_scale - other.scale));
            return Decimal.new_with_parts(this_value - other_value, max_scale);
        }
    }

    operator *(other: Int|Float|Decimal) {
        if other isa Int {
            other = Decimal.new(other);
        } elsif other isa Float {
            other = Decimal.new(other);
        }

        return Decimal.new_with_parts(this.value * other.value, this.scale + other.scale);
    }

    reverse operator *(lhs) {
        return this._op_impl_mul(lhs);
    }

    operator /(other: Int|Float|Decimal) {
        if other isa Int {
            other = Decimal.new(other);
        } elsif other isa Float {
            other = Decimal.new(other);
        }

        return Decimal.new_with_parts(this.value * pow(10, other.scale) / other.value, this.scale);
    }

    func align(other) {
        if this.scale == other.scale {
            return [this, other];
        }

        val max_scale = max(this.scale, other.scale);
        val this_value = this.value * pow(10, max_scale - this.scale);
        val other_value = other.value * pow(10, max_scale - other.scale);

        val a0 = alloc(Decimal){ .value=this_value,  .scale=max_scale };
        val a1 = alloc(Decimal){ .value=other_value, .scale=max_scale };

        return [a0,a1];
    }

    func comp(other) {
        if other isa Int {
            other = Decimal.new(other);
        } elsif other isa Float {
            other = Decimal.new(other);
        } elsif !(other isa Decimal) {
            throw alloc(Unimplemented);
        }

        val a = this.align(other);

        if a[0].value == a[1].value {
            return CompareResult::eq;
        } elsif a[0].value > a[1].value {
            return CompareResult::gt;
        } else {
            return CompareResult::lt;
        }
    }

    func prettyprint(fmt: String = "") {
        if fmt == "" {
            return this.default_prettyprint();
        }

        val parts = fmt.split(".");
        if parts.len() != 2 || parts[0] != "" {
            return this.default_prettyprint();
        }

        val n_maybe = Int.parse(parts[1]);
        match n_maybe {
            case Err => { return this.default_prettyprint(); },
            case Ok(N) => {
                if N <= 0 {
                    return this.default_prettyprint();
                }

                if this.scale <= N {
                    return this.default_prettyprint();
                }

                val drop = this.scale - N;
                val factor = 10.pow(drop);
                val v = this.value;

                val rounded =
                    v >= 0 ? (v + factor / 2) / factor
                        : (v - factor / 2) / factor;

                return Decimal.new_with_parts(rounded, N).default_prettyprint();
            }
        }
    }

    func default_prettyprint() {
        val abs_value_str = prettyprint(this.value.abs());
        val sign = "";
        if this.value < 0 { sign = "-"; }

        if this.scale == 0 {
            return sign + abs_value_str;
        }

        val value_str = abs_value_str;
        val len = value_str.len();

        if len <= this.scale {
            return sign + "0." + "0" * (this.scale - len) + value_str;
        }

        val integer_part = value_str.substring(0, len - this.scale - 1);
        val fractional_part = value_str.substring(len - this.scale, len - 1);
        
        return sign + integer_part + "." + fractional_part;
    }

    include TotalOrdering
}
