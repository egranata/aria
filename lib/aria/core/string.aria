# SPDX-License-Identifier: Apache-2.0
flag: no_std;

# this is conceptually the same as what's in aria.string.classes
# but we don't want to import from the core builtin library, so
# the duplication of this rather trivial code is acceptable
func is_digit(s: String) {
    match s {
        == "0" => { return true; },
        == "1" => { return true; },
        == "2" => { return true; },
        == "3" => { return true; },
        == "4" => { return true; },
        == "5" => { return true; },
        == "6" => { return true; },
        == "7" => { return true; },
        == "8" => { return true; },
        == "9" => { return true; },
    } else {
        return false;
    }
}

extension String {
    struct EncodingError {
        type func new(msg: String) {
            return alloc(This) {
                .msg = msg
            };
        }

        instance func prettyprint() {
            return "encoding error: {0}".format(this.msg);
        }
    }

    func repeat(n: Int) {
        if n == 0 { return ""; }
        if n == 1 { return this; }
        val ret = this;
        while n > 1 {
            ret = ret + this;
            n -= 1;
        }
        return ret;
    }

    operator *(rhs: Int) {
        return this.repeat(rhs);
    }

    reverse operator *(lhs: Int) {
        return this.repeat(lhs);
    }

    func trim() {
        return this.trim_head().trim_tail();
    }

    func prettyprint() {
        return this;
    }

    func format(...) {
        val ret = "";
        val chars = this.chars();
        val len = this.len();
        val idx = 0;

        while idx < len {
            val c = chars[idx];

            if c == "{" && idx + 1 < len && chars[idx + 1] == "{" {
                ret += "{";
                idx += 2;
                continue;
            }

            if c == "}" && idx + 1 < len && chars[idx + 1] == "}" {
                ret += "}";
                idx += 2;
                continue;
            }

            if c == "{" {
                idx += 1;
                val num_str = "";
                val style_str = "";
                val has_style = false;
                val found_closing_brace = false;

                while idx < len {
                    val c = chars[idx];

                    if c == "}" {
                        idx += 1;
                        found_closing_brace = true;
                        break;
                    } elsif c == ":" && !has_style {
                        has_style = true;
                        idx += 1;
                    } elsif !has_style {
                        num_str += c;
                        idx += 1;
                    } else {
                        style_str += c;
                        idx += 1;
                    }
                }

                if !found_closing_brace {
                    if has_style {
                        ret += "{" + num_str + ":" + style_str;
                    } else {
                        ret += "{" + num_str;
                    }
                    continue;
                }

                match Int.parse(num_str) {
                    case Some(i) => {
                        if i >= varargs.len() {
                            if has_style {
                                ret += "{" + num_str + ":" + style_str + "}";
                            } else {
                                ret += "{" + num_str + "}";
                            }
                        } else {
                            val arg = varargs[i];
                            if hasattr(arg, "prettyprint") {
                                val pp_arity = arity(arg.prettyprint);
                                val accepts_1 = pp_arity.can_call_with_argc(1);
                                val accepts_0 = pp_arity.can_call_with_argc(0);
                                # Decision logic for calling prettyprint:
                                # - If prettyprint(x) is a valid signature and no style string is provided,
                                #   we would prefer to call prettyprint() with no arguments.
                                # - However, if calling with no arguments would fail, use the 1-argument version
                                #   with an empty style string if that's the only allowed call.
                                if (has_style && accepts_1) || (!has_style && accepts_1 && !accepts_0) {
                                    ret += arg.prettyprint(style_str);
                                } elsif accepts_0 {
                                    ret += arg.prettyprint();
                                } else {
                                    ret += prettyprint(arg);
                                }
                            } else {
                                ret += prettyprint(arg);
                            }
                        }
                    }
                } else {
                    if has_style {
                        ret += "{" + num_str + ":" + style_str + "}";
                    } else {
                        ret += "{" + num_str + "}";
                    }
                }

                continue;
            }

            ret += c;
            idx += 1;
        }

        return ret;
    }

    func substring(from: Int, to: Int) {
        val ret = "";
        while from < this.len() {
            if from > to {
                break;
            }
            ret = ret + this[from];
            from += 1;
        }

        return ret;
    }

    func hash() {
        val ret = 0;
        for b in this.bytes() {
            ret += 31 * b;
        }

        return ret;
    }
}
