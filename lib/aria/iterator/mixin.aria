# SPDX-License-Identifier: Apache-2.0
import ok, err from aria.core.result;

struct FilteringIterator {
    type func new(i, f) {
        return alloc(This){
            .it = i,
            .clause = f,
        };
    }

    func next() {
        while true {
            val nv = this.it.next();
            if nv.done {
                return nv;
            }
            if this.clause(nv.value) {
                return nv;
            }
        }
    }
}

struct MappingIterator {
    type func new(i, f) {
        return alloc(This){
            .it = i,
            .clause = f,
        };
    }

    func next() {
        while true {
            val nv = this.it.next();
            if nv.done {
                return nv;
            }
            return Box() {
                .done = false,
                .value = this.clause(nv.value)
            };
        }
    }
}

struct CountReducer {
    type func new() = alloc(This) {.count = 0};
    operator () (_x,_y) {
        this.count += 1;
        return this;
    }
}

struct TruncatedIterator {
    type func new(i, n: Int) {
        return alloc(This){
            .it = i,
            .remaining = n,
        };
    }

    func next() {
        if this.remaining <= 0 {
            return Maybe::None;
        }
        this.remaining -= 1;
        return this.it.next();
    }
}

mixin Iterator {
    # allow running a for loop directly on an iterator
    func iterator() = this;

    func where(f) = FilteringIterator.new(this,f);

    func map(f) = MappingIterator.new(this,f);

    func to_list() = this.reduce(|l,i| => l.append(i), []);

    func flatten_results() {
        val out = [];
        for v in this {
            match v {
                isa Result and case Ok(x) => { out.append(x); },
                isa Result and case Err(e) => { return err(e); },
            } else {
                out.append(v);
            }
        }
    
        return ok(out);
    }

    func all(f) = !this.any(|x| => !f(x));

    func any(f) = this.find(f).is_Some();

    func find(f) {
        for v in this {
            if f(v) {
                return Maybe::Some(v);
            }
        }
        return Maybe::None;
    }

    func position(f) {
        val index = 0;
        for v in this {
            if f(v) {
                return Maybe::Some(index);
            }
            index += 1;
        }
        return Maybe::None;
    }

    func reduce(f, v0) {
        val acc = v0;
        for v in this {
            acc = f(acc, v);
        }
        return acc;
    }

    func sum(v0=0) = this.reduce(|x,y| => x+y, v0);

    func product(v0=1) = this.reduce(|x,y| => x*y, v0);

    func max() {
        val first_item = this.next();
        if first_item.done {
            return Maybe::None;
        }
        val current_max = first_item.value;
        for v in this {
            if v > current_max {
                current_max = v;
            }
        }
        return Maybe::Some(current_max);
    }

    func min() {
        val first_item = this.next();
        if first_item.done {
            return Maybe::None;
        }
        val current_min = first_item.value;
        for v in this {
            if v < current_min {
                current_min = v;
            }
        }
        return Maybe::Some(current_min);
    }

    func count() {
        val r = CountReducer.new();
        return this.reduce(r, 0).count;
    }

    func first() = this.nth(0);

    func last() {
        val last_value = Maybe::None;
        for v in this {
            last_value = Maybe::Some(v);
        }
        return last_value;
    }

    func nth(n: Int) {
        if n < 0 {
            return Maybe::None;
        }
        val current_index = 0;
        for v in this {
            if current_index == n {
                return Maybe::Some(v);
            }
            current_index += 1;
        }
        return Maybe::None;
    }

    func skip(n: Int) {
        while n > 0 {
            val _ = this.next();
            n -= 1;
        }
        return this;
    }

    func truncate(n: Int) = TruncatedIterator.new(this, n);
}

extension FilteringIterator {
    include Iterator
}

extension MappingIterator {
    include Iterator
}

extension TruncatedIterator {
    include Iterator
}

extension List.ListIterator {
    include Iterator
}

mixin Iterable {
    func where(f) = this.iterator().where(f);
    func map(f) = this.iterator().map(f);
    func reduce(f,v0) = this.iterator().reduce(f,v0);
    func to_list() = this.iterator().to_list();
    func all(f) = this.iterator().all(f);
    func any(f) = this.iterator().any(f);
    func find(f) = this.iterator().find(f);
    func position(f) = this.iterator().position(f);
    func sum(v0=0) = this.iterator().sum(v0);
    func product(v0=1) = this.iterator().product(v0);
    func max() = this.iterator().max();
    func min() = this.iterator().min();
    func count() = this.iterator().count();
    func first() = this.iterator().first();
    func last() = this.iterator().last();
    func nth(n) = this.iterator().nth(n);
    func skip(n: Int) = this.iterator().skip(n);
    func truncate(n: Int) = this.iterator().truncate(n);
}

extension List {
    include Iterable
}
