# SPDX-License-Identifier: Apache-2.0

import Map from aria.structures.map;
import JsonValue from aria.json.value;
import JsonNull from aria.json.value;
import ok, err from aria.core.result;

# this is a type-check only prototype
func _to_json_thing(this) {}

struct JsonConvertError {
    type func new(why: String) {
        return alloc(This) {
            .message = why,
        };
    }

    func prettyprint() {
        return "JsonConvertError: " + this.message;
    }
}

func json_err(msg) {
    return err(JsonConvertError.new(msg));
}

extension JsonValue {
    type func new_with_value(x) {
        match x {
            isa String => {
                return ok(JsonValue::String(x));
            },
            isa Int => {
                return ok(JsonValue::Number(x + 0.0f));
            },
            isa Float => {
                return ok(JsonValue::Number(x));
            },
            isa Bool => {
                return ok(JsonValue::Boolean(x));
            },
            isa List => {
                val ret = [];
                for item in x {
                    ret.append(JsonValue.new_with_value(item)??);
                }
                return ok(JsonValue::Array(ret));
            }
            isa Map => {
                val ret = Map.new();
                for item in x {
                    val key = item.key;
                    if !(key isa String) {
                        key = format("{0}", key);
                    }
                    val value = JsonValue.new_with_value(item.value)??;
                    ret.set(key, value);
                }
                return ok(JsonValue::Object(ret));
            }
            isa JsonNull => {
                return ok(JsonValue::Null(alloc(JsonNull)));
            }
        } else {
            if hasattr(x, "to_json_value") {
                val to_json_value = x.to_json_value;
                if arity(to_json_value).can_call_with_argc(0) {
                    return to_json_value()??;
                }
            }
        }

        return json_err("type of value {0} cannot be converted as JSON".format(x));
    }
}

func escape_json_string(s: String) {
    val result = "";
    for c in s.chars() {
        if c == '"' {
            result += '\\"';
        } elsif c == '\\' {
            result += "\\\\";
        } elsif c == '\n' {
            result += "\\n";
        } elsif c == '\r' {
            result += "\\r";
        } elsif c == '\t' {
            result += "\\t";
        } elsif c == '\b' {
            result += "\\b";
        } elsif c == '\f' {
            result += "\\f";
        } else {
            result += c;
        }
    }
    return result;
}

extension JsonValue {
    func to_json_string() {
        match this {
            case Object(map) => {
                val parts = [];
                for entry in map {
                    val key = escape_json_string(entry.key);
                    val value_str = entry.value.to_json_string();
                    parts.append('"' + key + '":' + value_str);
                }
                return "{" + parts.join() + "}";
            },

            case Array(items) => {
                val parts = [];
                for item in items {
                    parts.append(item.to_json_string());
                }
                return "[" + parts.join() + "]";
            },

            case String(s) => {
                return '"' + escape_json_string(s) + '"';
            },

            case Number(n) => {
                return "{0}".format(n);
            },

            case Boolean(b) => {
                return b ? "true" : "false";
            },

            case Null(x) => {
                return "null";
            },
        }
    }
}
