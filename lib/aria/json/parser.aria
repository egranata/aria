# SPDX-License-Identifier: Apache-2.0

import Map from aria.structures.map;
import aria.string.classes;
import JsonValue from aria.json.value;
import JsonNull from aria.json.value;
import ok, err from aria.core.result;

struct JsonStream {
    type func new(s) {
        return alloc(This) { .input = s.chars(), .pos = 0 };
    }

    func peek() {
        return this.pos < this.input.len() ? this.input[this.pos] : Maybe::None;
    }

    func next() {
        val c = this.peek();
        this.pos += 1;
        return c;
    }

    func eat(expected) {
        if this.peek() == expected {
            this.next();
            return true;
        } else {
            return false;
        }
    }

    func skip_whitespace() {
        while true {
            val c = this.peek();
            if c == ' ' || c == '\t' || c == '\n' || c == '\r' {
                this.next();
            } else {
                break;
            }
        }
    }
}

extension JsonValue {
    type func parse(s) {
        return ok(parse_value(JsonStream.new(s))??);
    }
}

struct JsonParseError {
    type func new(why: String) {
        return alloc(This) {
            .message = why,
        };
    }

    func prettyprint() {
        return "JsonParseError: " + this.message;
    }
}

func json_err(msg) {
    return err(JsonParseError.new(msg));
}

func parse_value(stream) {
    stream.skip_whitespace();
    val c = stream.peek();

    if c == '"' {
        return JsonValue::String(parse_string(stream)??);
    } elsif c == '{' {
        return JsonValue::Object(parse_object(stream)??);
    } elsif c == '[' {
        return JsonValue::Array(parse_array(stream)??);
    } elsif c == 't' {
        return parse_true(stream)??;
    } elsif c == 'f' {
        return parse_false(stream)??;
    } elsif c == 'n' {
        return parse_null(stream)??;
    } elsif c.is_digit() || c == '-' {
        return JsonValue::Number(parse_number(stream))??;
    } else {
        return json_err("Not a valid JSON value: " + c);
    }
}

func parse_string(stream) {
    if !stream.eat('"') {
        return json_err("missing quotes in JSON string");
    }

    val result = "";
    while true {
        val c = stream.next();
        if c == '"' {
            break;
        } elsif c == '\\' {
            val esc = stream.next();
            if esc == 'n' {
                result += '\n';
            } elsif esc == 't' {
                result += '\t';
            } elsif esc == '"' {
                result += '"';
            } elsif esc == '\\' {
                result += '\\';
            } else {
                return json_err("invalid escape sequence in JSON string");
            }
        } else {
            result += c;
        }
    }

    return ok(result);
}

func parse_number(stream) {
    val text = "";
    if stream.peek() == '-' {
        text += stream.next();
    }

    while true {
        val c = stream.peek();
        if c.is_digit() {
            text += stream.next();
        } else {
            break;
        }
    }

    if stream.peek() == '.' {
        text += stream.next();
        while true {
            val c = stream.peek();
            if c.is_digit() {
                text += stream.next();
            } else {
                break;
            }
        }
    }

    return Float.parse(text)??;
}

func parse_true(stream) {
    if stream.next() != 't' || stream.next() != 'r' || stream.next() != 'u' || stream.next() != 'e' {
        return json_err("invalid boolean true value in JSON");
    } else {
        return ok(JsonValue::Boolean(true));
    }
}

func parse_false(stream) {
    if stream.next() != 'f' || stream.next() != 'a' || stream.next() != 'l' || stream.next() != 's' || stream.next() != 'e' {
        return json_err("invalid boolean false value in JSON");
    } else {
        return ok(JsonValue::Boolean(false));
    }
}

func parse_null(stream) {
    if stream.next() != 'n' || stream.next() != 'u' || stream.next() != 'l' || stream.next() != 'l' {
        return json_err("invalid null value in JSON");
    } else {
        return ok(JsonValue::Null(alloc(JsonNull)));
    }
}

func parse_object(stream) {
    val map = Map.new();
    stream.eat('{');
    stream.skip_whitespace();

    if stream.peek() == '}' {
        stream.next();
        return map;
    }

    while true {
        stream.skip_whitespace();
        val key = parse_string(stream)??;
        stream.skip_whitespace();
        if !stream.eat(':') {
            return json_err("Invalid JSON object key-value pair");
        }

        val value = parse_value(stream)??;
        map.set(key, value);
        stream.skip_whitespace();

        if stream.eat('}') {
            break;
        } elsif stream.eat(',') {
            continue;
        } else {
            return json_err("Unexpected character in JSON object");
        }
    }

    return ok(map);
}

func parse_array(stream) {
    val list = [];
    stream.eat('[');
    stream.skip_whitespace();

    if stream.peek() == ']' {
        stream.next();
        return list;
    }

    while true {
        val value = parse_value(stream)??;
        list.append(value);
        stream.skip_whitespace();

        if stream.eat(']') {
            break;
        } elsif stream.eat(',') {
            continue;
        } else {
            return json_err("Unexpected character in JSON array");
        }
    }

    return ok(list);
}
